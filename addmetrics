# Rewrite write_scientific_note in analyze_thrml_cst.py to avoid f-strings and brace conflicts.
import io, re, sys, subprocess

path = "/mnt/data/analyze_thrml_cst.py"
with open(path, "r") as f:
    code = f.read()

start = code.find("def write_scientific_note")
end = code.find("def main():")
prefix = code[:start]
suffix = code[end:]

new_func = r'''
def write_scientific_note(off_stats, on_stats, tz="Europe/Madrid"):

**Date:** $ts  
    from string import Template
    ts = datetime.utcnow().strftime("%Y-%m-%d %H:%M UTC")

    tpl = Template("""# A Toy Thermodynamic Model of Emergent Structure with Local Memory
**Authors:** Deirdre (concept), Assistant (implementation)

## 1. Motivation
We study whether simple local adaptation (“memory”) in a discrete energy-based model on a sparse graph can stabilize coherent patterns under chaotic forcing. The model is a toy abstraction of a “cosmic synapse” idea: nodes are interacting units with pairwise couplings and global bias components.

## 2. Methods
We analyze spin trajectories $s_i(t) \\in \\{-1,+1\\}$ generated by a block-Gibbs sampler (THRML). The graph is k-NN in 3D; couplings are inverse-distance and clipped for stability; a baseline bias mimics a global field. A small Lorenz-derived drive perturbs biases over time; an optional local-memory rule adjusts biases toward neighbor means.

**Metrics**
- **Magnetization** $m(t)=\\frac{1}{N}\\sum_i s_i(t)$
- **Binary Shannon entropy** $H(t)$ from fraction of $+1$ spins
- **Neighbor correlation** $C_1(t)=\\langle s_i s_j\\rangle$ over edges
- **Energy proxy** $E(t)=-\\sum_{(i,j)}J_{ij}s_i s_j-\\sum_i b_i s_i$ (baseline bias)
- **Susceptibility proxy**: sliding-window variance of $m(t)$

We compare two conditions: **memory OFF** (no adaptation) and **memory ON** (small Hebbian-like bias update).

## 3. Results (summary statistics)

**Memory OFF**
- $\\bar m$ = ${m_off:.4f} ± ${mstd_off:.4f}  
- $\\bar H$ = ${H_off:.4f}  
- $\\overline{C_1}$ = ${C1_off:.4f}  
- $\\bar E$ = ${E_off:.4f}  
- $\\overline{\\chi}$ = ${chi_off:.4f}

**Memory ON**
- $\\bar m$ = ${m_on:.4f} ± ${mstd_on:.4f}  
- $\\bar H$ = ${H_on:.4f}  
- $\\overline{C_1}$ = ${C1_on:.4f}  
- $\\bar E$ = ${E_on:.4f}  
- $\\overline{\\chi}$ = ${chi_on:.4f}

**Figures**
- Magnetization: `analysis/magnetization_off.png`, `analysis/magnetization_on.png`  
- Entropy: `analysis/entropy_off.png`, `analysis/entropy_on.png`  
- Neighbor correlation: `analysis/corr_off.png`, `analysis/corr_on.png`  
- Energy proxy: `analysis/energy_off.png`, `analysis/energy_on.png`  
- Susceptibility: `analysis/suscept_off.png`, `analysis/suscept_on.png`  

## 4. Interpretation
Across these metrics, differences between memory OFF and ON indicate how local adaptation reshapes the explored energy landscape. Increased neighbor correlation and reduced susceptibility suggest more stable, coherent configurations under memory. If entropy stays high while correlation increases, the system may be forming structured but diverse patterns—consistent with self-organizing regimes rather than frozen order.

## 5. Limitations & Next Steps
- The “energy” is a proxy (baseline bias); future runs should log full time-varying biases.
- Couplings are toy inverse-distance; try alternative kernels and noise schedules.
- Add proper order-parameter phase scans over temperature $\\beta$ and memory rate.

## 6. Conclusion
This experiment provides initial, quantitative evidence that simple local memory can promote coherent structure under weak chaotic drive in a sparse interacting system. It does not prove a physical theory, but it sharpens testable hypotheses about emergence and adaptive order.

---

*Reproducibility:* run `thrml_cst_test.py` to generate two runs, then `analyze_thrml_cst.py`.
""")

    md = tpl.substitute(
        ts=ts,
        m_off=off_stats.get('mag_mean', float('nan')),
        mstd_off=off_stats.get('mag_std', float('nan')),
        H_off=off_stats.get('entropy_mean', float('nan')),
        C1_off=off_stats.get('corr_mean', float('nan')),
        E_off=off_stats.get('energy_mean', float('nan')),
        chi_off=off_stats.get('suscept_mean', float('nan')),
        m_on=on_stats.get('mag_mean', float('nan')),
        mstd_on=on_stats.get('mag_std', float('nan')),
        H_on=on_stats.get('entropy_mean', float('nan')),
        C1_on=on_stats.get('corr_mean', float('nan')),
        E_on=on_stats.get('energy_mean', float('nan')),
        chi_on=on_stats.get('suscept_mean', float('nan')),
    )

    with open("Scientific_Note.md","w") as f:
        f.write(md)
'''

new_code = prefix + new_func + "\n" + suffix
with open(path, "w") as f:
    f.write(new_code)

# Rerun analysis
proc = subprocess.run([sys.executable, "/mnt/data/analyze_thrml_cst.py"], capture_output=True, text=True)
print(proc.stdout)
print(proc.stderr)

# List artifacts
import os
def listp(p): 
    return [os.path.join(p,f) for f in os.listdir(p)] if os.path.exists(p
